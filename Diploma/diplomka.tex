% Nejprve uvedeme tridu dokumentu s volbami
%\documentclass[bc,male,java,dept460]{diploma}		% jednostranny dokument
\documentclass[bc,male,java,dept460]{diploma}		% oboustranny dokument
\usepackage[czech]{babel}

% Zadame pozadovane vstupy pro generovani titulnich stran.
\ThesisAuthor{Zdeněk Gold}

% U bakalarske praxe neni nutne nazev zadavat
\ThesisTitle{Genetické programování v platformově nezávislém jazyce}

% U bakalarske praxe neni nutne anglicky nazev zadavat
\EnglishThesisTitle{Genetic Programming Based on a Platform Independent Language}

\SubmissionDate{10. října 2015}

\PrintPublicationAgreement{true}

\Thanks {
Rád bych poděkoval prof. Ing. Ivan Zelinka, Ph.D. za užitečné rady, zajímavé
podměty a věnovaný čas při tvorbě této práce. Rovněž velmi děkuji svým rodičům a dalším rodinným příslušníkům za všestrannou podporu během studia.
}

\CzechAbstract {}

\CzechKeywords {
EVT, evoluční algoritmy, genetické programování, syntaktický strom, křížení, mutace, selekce, program, jedinec, symbolická regrese, Java
}

\EnglishAbstract {
This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract.
}

\EnglishKeywords {
EVT, evolutionary algorithm, genetic programming, syntactic tree, cross, mutate, selection, program, individual, symbolic regression, Java
}

% Pridame pouzivane zkratky (pokud nejake pouzivame).
\AddAcronym {EVT} {Evoluční výpočetní techniky}
\AddAcronym {GA} {Genetický algoritmus}
\AddAcronym {GP} {Genetické programování}
\AddAcronym {SR} {Symbolická regrese}

%\ThesisAssignmentImagePath{Figures/Zadani}

% Zadame soubor s digitalizovanou podobou prohlaseni
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni
\DeclarationImageFile {Figures/Prohlaseni.jpg}

% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages

% Asi urcite budeme potrebovat obsah prace.
\tableofcontents
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci tabulky? Pokud ano vysazime jejich seznam.
% Pokud ne smazeme nasledujici makro.
\listoftables
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci obrazky? Pokud ano vysazime jejich seznam.
\listoffigures
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci vypisy programu? Pokud ano vysazime jejich seznam.
\lstlistoflistings
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Zacneme uvodem
\section{Úvod}
\label{sec:Uvod}
\paragraph*{}
Tento text je ukázkou sazby diplomové práce v \LaTeX{}u pomocí třídy dokumentů \verb|diploma|.
Pochopitelně text není skutečnou diplomovou prací, ale jen ukázkou použití
implementovaných maker v praxi. V kapitole \ref{sec:Typo} jsou ukázky použití
různých maker a prostředí. V kapitole \ref{sec:Conclusion} bude \uv{jako závěr}. Zároveň tato kapitola slouží jako ukázka generování křížových odkazů v \LaTeX{}u.

\section{Evoluční algoritmy}
\paragraph*{}
Před tím, než se pustíme do popisu toho, co jsou to evoluční algoritmy a na jakých principech fungují, se seznámíme s tím, co jsou to „evoluční výpočetní techniky“.

\subsection{Pojmy z oblasti evolučních algoritmů}
\paragraph*{}
Před tím, než se pustíme do popisu toho, co jsou to evoluční algoritmy a na jakých principech fungují, se seznámíme s tím, co jsou to „evoluční výpočetní techniky“.

\subsubsection{Jedinec}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potomkům.

\subsubsection{Populace}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potomkům.

\paragraph*{}
Typickým rysem evolučních algoritmů je, že jsou založeny na práci s populací jedinců. Populace může být znázorněna jako matice NxM, kde sloupce představují jednotlivé jedince. Každý jedinec představuje aktuální řešení danéího problému. S každým jedincem je navíc spojena hodnota účelové funkce, která říká, jak vhodný je jedinec pro další vývoj populace.

\paragraph*{}
Hlavní činnosti evolučních algoritmů je cyklické vytváření nových populací, tedy náhrada starách populací novými. To vše pomocí přesně definovaných matematických pravidel.

\paragraph*{}
K vytvoření populace je třeba nadefinovat tzv. vzor, podle kterého se generuje celá počáteční populace. Ve vzoru jsou pro každý parametr konkrétního jedince definovány tři konstanty, a to typ proměnné a hranice intervalu, v němž může pohybovat hodnota parametru. Volba hranice je velmi důležitý krok, protože při jejich nevhodném zvolení se může stát, že budou nalezena řešení , která nebudou možné fyzikálně realizovat nebo nebudou mít opodstatnění. 

\paragraph*{}
Další neméně důležtý význam hranic souvisí se samotným evolučním procesem. Může se stát, že daný problém bude reprezentován plochou, která bude nabývat lokálních extrémů stále větších hodnot se vzrůstající vzdáleností od počátku. To způsobí, že evoluce bude nacházet stále nová řešení až do nekonečna. Je to způsobeno tím, že evoluční proces směřuje do stále hlubších a vzdálenějších extrémů.
Populace je na základě vzorového jedince vygenerována podle vzorce.

\paragraph*{}
$\Theta(1+\alpha)$.  

\paragraph*{}
Tento vztah zajišťuje, že všchny parametry jedinců budou náhodně vygenerovány uvnitř povolených hranic prostoru možných řešení.

\paragraph*{}
Zobrazení o tom, jak kvalitně proběhla evoluce, se provádí pomocí tzv. historie vývoje hodnoty účelové funkce ve formě jednoduchého grafu. Na něm je vykreslena závislost vývoje účelové funkce na aktuálním počtu jejich ohodnocení. Jde o sekvenci nejhorších a nejlepších řešení z jednotlivých populací. Výhodnější je však zobrazení závislosti hodnoty účelové funkce na aktuálním počtu jejich ohodnocení. To proto, že u evolučních cyklů se provádí u jednotlivých algoritmů různý počet ohodnocení účelové funkce. U prvního případu může být pomalejší konvergence hodnoty účelové funkce zobrazena jako rychlejší a naopak. Skutečná informace o kvalitě evoluce je pak zkreslená. U druhého způsobu můžeme objektivně porovnávat různé typy algoritmů bez ohledu na jejich vnitřní struktuře.
Kromě vývoje nejlepšího jedince je pak vhodné zobrazovat vývoj i nejhoršího jedince z populace, a to do jednoho grafu.

\paragraph*{}
Vývoj populace musí být vždy konvergentní k lepším hodnotám, což znamená, že nemůže nikdy vykazovat divergenci. V daném algoritmu funguje tzv. „elitismus“, který slouží jako jakýsi jednosměrný filtr, jenž propouští do nové populace pouze ta řešení, která jsou lepší či stejně dobrá jako ta ze staré populace.

\subsubsection{Účelová funkce}
\paragraph*{}
Každého vytvořeného reprezentativního jedince je třeba ohodnotit v rámci celé populace čítající desídky jiných jedinců tak, aby bylo možné některé jedince (řešení) upřednostňovat při výběru pro křížení před jinými (horšími) řešeními.
Hodnota takto přidělená jedinci je označována za jeho fitness (neboli vhodnost).

\subsubsection{Operátor mutace}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potomkům.

\subsubsection{Operátor křížení}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potomkům.

\subsubsection{Elitismus}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů
plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potomkům.

\subsection{Životní cyklus evolučních algoritmů}

\InsertFigure{Figures/evol-progress.png}{0.7\textwidth}{Průběh evolučního algoritmu}{fig:EvolProgress}

\paragraph*{}
Životní cyklus algoritmů z rodiny evolučních algoritmů je v zásadě totožný a lze jej zjedodušeně popsat několika kroky, jak je znázorněno na obr. Na počátku je v rámci námi zkoumané instance problématiky náhodně vytvořena populace, a to z genofondu, který příslučí danému alforitmu.
<<<<<<< HEAD

\paragraph*{}
Nad takto vytvořenou populací je za pomocí fitness funkce (obecné ohodnocení kvality řešení) daného problému každému jedinci přiřazena hodota, vyjadřující míru vhodnosti jedince, tzv. fitness. Ohodnocená populace je dále podrobena selekci jedinců vhodných k reprodukci. Selektivní funkce přímo pracuje s přiřazenými fitness hodnotami a na základě těchto hodot ovlivňuje míru pravděpodobnosti jedinců v populaci.

\paragraph*{}
V reprodukční části algoritmu dochází k výměně genetických informací nově vzniklých jedinců. Typickými operátory je křížení - vzájemná výměna části fenotypů mezi více jedinci a mutace - náhodné pozměnení fenotypů jedince.

=======

\paragraph*{}
Nad takto vytvořenou populací je za pomocí fitness funkce (obecné ohodnocení kvality řešení) daného problému každému jedinci přiřazena hodota, vyjadřující míru vhodnosti jedince, tzv. fitness. Ohodnocená populace je dále podrobena selekci jedinců vhodných k reprodukci. Selektivní funkce přímo pracuje s přiřazenými fitness hodnotami a na základě těchto hodot ovlivňuje míru pravděpodobnosti jedinců v populaci.

\paragraph*{}
V reprodukční části algoritmu dochází k výměně genetických informací nově vzniklých jedinců. Typickými operátory je křížení - vzájemná výměna části fenotypů mezi více jedinci a mutace - náhodné pozměnení fenotypů jedince.

>>>>>>> 9b2bd386a991002e1fe1c8ba5b730b9ad2b17244
\subsection{Genetický algoritmus (GA)}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potom

\subsection{Particle Swarm}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potom

\subsection{SOMA}
\paragraph*{}
Podle klasické Darwinové a Mendelovy teorie evoluce, je uznáváno dogma, podle něhož se jednotlivé druhy vyvíjejí tak, že jsou z rodičů plozeni potomci, kteří podléhají při svém vzniku mutacím. Rodiče a potomci nevhodní pro aktuální životní prostředí vymírají cyklicky po tzv. generacích, čímž uvolňují místo novým rodičům a jejich potom

\section{Genetické programování (GP)}
\paragraph*{}
Název "genetické programování" (dále už jen GP) se zrodil již počátkem 80. let, kdy byl představen jako algoritmus pro využití v problémeh jako je predikce, klasifikace, aproximace, tvorba programů. GP je odvětvím evolučních výpočetních technik.
Otcem GP je standfordský informatik John Koza \cite{kozagp,kozagp2}. Díky konceptu, který vytvořil, lze využít při tvorbě programů stejných evolučních operátorů, jaké obsahuje GA (křížení, mutace).

\paragraph*{}
V zásadě lze označit GP jako hledaní nejlépe ohodnoceného (hodícího se) programu ve skupině přípustných programů, kdy populace požadované velikosti – obvykle několika stovek jedinců – je geneticky křížena a mutována.
Jde o program, který umožňuje konstruovat další programy. Může jít o algoritmicky založenou evoluční metodologii, inspirovananou biologickými evolučními procesy (přežití nejschopnějších), ke zjištění, který program nejlépe odpovídá řešení.

\paragraph*{}
Proto, abychom pochopili smysl tohoto algoritmu, položmě si tuto otázku: "Jak se může počítač naučit řešit  problémy bez toho, abychom jej k tomu přímo nenaprogramovali? Jinými slovy, jak může počítač sám dělat to co potřebujeme aby dělal, bez toho abychom mu to přesně řekli?" Touto otázkou Arthur Samuel již v roce 1959 otevřel debatu kolem umělé inteligence.

\paragraph*{}
Paradigma genetického programování následuje přístup k řešení problému klasickým genetickým algoritmem s navýšením komplexnosti struktury jedince procházející adaptací. Takové jedince tvoří složitější struktury, které tvoří hirearchicky členěné počítačové programy, vyznačující se různou délkou a tvarem. Jsou to zejména problémy jako umělá inteligence, symbolická regrese, strojové učení, které lze přeformulovat na požadavek nalezení počítačového programu, který bude na výstupu generovat jiné programy jako vstup ke konkrétní úloze. Koza ve své knize tvrdí, že proces řešení těchto problémů lze formulovat jako hledání nejvhodnějšího počítačového programu v prostoru všech možných programů. Prohledávací prostor je tvořen funkcemi a terminály odpovídající doméně problému. A právě genetické programování nám poskytuje postup, jak pomocí genetického šlechtění nalézt nejlépe odpovídající program k dané úloze.

\paragraph*{}
Typickým příkladem pro genetické programování je model, který se snaží nalézt logický výraz, jehož výsledkem je buď ano či ne. Můžeme si to představit na modelu banky, která eviduje své zákazníky a jejich úvěry. U každého záznamu zákazníka známe cílový stav (dostal úvěr nebo nedostal)? Nás potom ude zajímat, podle jakých kritérií bychom mohli tento model kategorizovat (čili vytvořit podmínky pro rozhodnutí, kdo úvěr dostane a kdo ne).

\paragraph*{}
Představme si situaci, kdy budeme chtít na základě nashromážděných dat vytvořit systém, který bude tyto data celkem dobře číst a popisovat je. Můžeme si to osvětlit na příkladě s bankou, která vede záznamy o úvěrech spolu s informacemi o věřitelích. Může se jednat o velikosti rodinného rozpočtu, počtu členů v rodině, počtu pracujících atd. S těmito parametry bychom potom chtěli vytvořit program, který by predikoval, zda je klient vhodným kandidátem na úvěr nebo ne.

\subsection{GA vs. GP}
\paragraph*{}
Přesto, že je tato technika GP poměrně mladá, patří k nejintenzivněji zkoumaným přístupům. Jak již bylo dříve zmíněno, vychází z analogie GA. Liší se v účelu použítí a také v reprezentaci jidince.

\paragraph*{}
Genetické algoritmy obecně jsou založeny na myšlence optimalizace hodnot nezávislých proměnných za pomocí adapatčního preparátu, který známe z přírodních zákonitostí \cite{evoltech}.

\begin{enumerate}
\item GA je založeno na optimalizaci hodnot nezávislých proměnných
\paragraph*{}
Všechny dříve popsané algoritmy vznikly a jsou většinou užitečné v případech, kdy hledáme určitou konfiguraci pro matematický model problému tak, abychom dosáhly určitých mezních hodnot. Popusťme však ještě uzdu své fantazii a představme si situaci, kdy budeme chtít řešit problém, u kterého si nejsme jistí, jaký má být správný postup v jeho řešení. V zásadě budeme chtít vytvořit algoritmus, který dokáže generovat jiné algoritmy (či programy), který budou daný problém řešit.

\item Jedinec v GP tvoří řešením pro nějaký model problému, který však už není pouze konfigurace, ale celý algoritmus (program).

\item Populace v GP je tvořena stovkami až tisíci jedinci, kdy každému jedinci odpovídá nějaký program
\end{enumerate}

\subsection{Úlohy řešené GP}
\begin{enumerate}
\item problém umělého mravence
\item nalezení herní strategie
\item generátor náhodných čísel
\item klasifikační problémy
\item nalezení vzoru
\end{enumerate}

\subsection{Reprezentace jedince}
\paragraph*{}
První problém, který po zrození myšlenky využít GA pro tvorbu a šlechtění počítačových programů je samotná reprezentace počítačového programu. Tato reprezentace musí být dostatečně obecná pro popsání v různých programovacích jazycích a zároveň zachovávat smyslupnost, syntaktickou správnost a spustitelnost nově vyšlechtěných programů při použití evolučních operátorů mutace a křížení.

\paragraph*{}
Vhodnou reprezentaci programů nalezl Koza v jazyce LISP, který reprezentuje programy jako S-výrazy, což je prakticky syntaktický strom, kterým reprezentují svoje programy překladače. Syntaktický strom je tvořeny dvěma možnými typy uzlů. Jsou to buď neterminály (tvoří funkce) a terminály (proměnné a konstanty). Při definici problémů se specifikuje množina neterminálů $\Pi=\{f_1,f_2,...,f_n\}$ a množina terminálů $\Gamma=\{t_1,t_2,...,t_n\}$. Příkladem syntaktického stromu, který znázorňuje výraz pro kombinaci k-té třídy z n prvků je na obrázku.

\paragraph*{}
Vlastnostmi se podobá neuronovými sítěmi. Od jiných evolučních algoritmů vyčnívá svou značně velkou populací (čítající tisíce jedinců) a z toho důvodu se jeví, jako značně pomalý algoritmus. Výhodou oproti jiným algoritmům (např. genetický algoritmus), které mají většinou lineárlní strukturu, zde tvoři jedince ne-lineární chromosomy (např. stromy či grafy).
\InsertFigure{Figures/Graf}{0.7\textwidth}{Nějaký graf}{fig:SampleGraph}

\paragraph*{}
Funkce $f_i$ z množiny $\Pi$ tvořící uzly syntaktického stromu jejichž argumenty reprezentují hrany vedoucí do hloubky o jedno větší. Terminály zastupují proměnné či konstanty umístěné v listových uzlech ukončují růst stromu a samotné individuum.

\subsection{Selekce}
\paragraph*{}
Cílem operátoru selekce je udžení v nové populaci co možná nejlepší řešení daného problému. Praktikuje se přitom přímá vazba na hodnotu fitness funkce jednotlivých jedinců (řešení). Výběr jedinců z populace je často aplikován  algoritmem, založeným na pravděpodobnosti.

\paragraph*{}
Variant selekce existuje několik. Běžne se v publikacích objevují vyskytují varianty označované jako \textit{roulete wheel selection}

\subsubsection*{Roulete wheel selection}
\paragraph*{}
V češtině pod názvem výběr ruletovým kolem, je operátor používaný v genetických algoritmů pro výběr potenciálně vhodných řešení pro následnou rekombinaci. K přiřazené fitness hodnotě se úměrně přidružuje pravděpodobnostní hodnota pro výběr jedince k další reprodukci. 

\paragraph*{}
Hodnota fitness je použita k přiřazení pravděpodobnosti pro výběr jednotlivých řešení následujícím způsobem. Pokud je $f_i$ přiřazená fitness hodnota jedince $i$ v populaci, pak pravděpodobnost, že toto řešení bude vybráno rovno $p_i=\frac{f_i}{\sum\limits_{j=1}^n f_j}$, kde $n$ je počet jedinců v populaci.

\paragraph*{}
Rozdělení pravděpodobnosti pro jednotlivé jedince si lze dobře představit na kole s výšeči, kde plocha každé výseči reprezentuje velikost pravděpodobností každého řešení. Odtud tedy název tohoto algoritmu.

\InsertFigure{Figures/roulete_wheel}{0.5\textwidth}{Ruletové kolo}{fig:SampleGraph}

\subsection{Algo1ritmus GP}
\paragraph*{}
Jak ilustruje níže uvedený obrázek \ref{fig:gp-paradigm}, algoritmus GP lze rozdělit do několika kroků, které budou následně rozebrány v závislosti na způsobu realizace.
\InsertFigure{Figures/gp-paradigm.png}{0.7\textwidth}{Průběh algoritmu Genetického programování}{fig:gp-paradigm}

\paragraph*{}
Prvním krokem je vytvoření náhodné populace jedinců, která bude sloužit k tvorbě dalších, vhodnějších řešeních.
Než se dostaneme ke šlechtění nových "lepších" jedinců, je potřeba, ve stávající populaci, nějak rozlišit vhodnější řešení reprezentováno jedincem, od řešení horšího. Proto je iniciační populace ohodnocena fitness funkcí.

\paragraph*{}
Před tím, něž budou řešení v populaci podrobena operátorům křížení nebo mutaci, stanou nejprve před genetickou operací selekce. Program je vybrán na základě dříve zmíněné Darwinovy teorie přírodního výběru. Konkrétně pro nás je to na základě předchozího ohodnocení.

\paragraph*{}
Ohodnocená populace je následně předaná genetickým operacím. Zde bude velmi záviset, s jakými parametry budou operace křížení či mutace operovat. Je třeba parametrem stanovit, jak velká část populace bude podrobena operaci mutace a naopak jak velká část operaci křížení. 

\subsection{Omezení GP}
\paragraph*{}
Koza ve své knize definuje \cite{kozagp} dvojí požadavky na množinu funkcí a terminálů. Je to požadavek uzavřenosti (closure) a postačitelnosti (sufficiency) obou množin. Uzavřenost množiny je splněna tehdy, pokud může libovolná funkce příjmout jako argument libovoulnou funkci z množiny funkcí či terminál z množiny terminálních symbolů. Uzavřenost zamezí tvorbu syntakticky nesprávných programů.

\paragraph*{}
Postačitelnst nám naproti tomu umožňuje, abychom byli schopní k danému problému nalézt odpovídající program (funkci), která by jej řešila. Díky tomu jsme schopni říci, že k danému problému můžeme vyjádřit řešení daného problému. Představme si problém nalezení potravy umělým mravencem v mřížkové soustavěm kterou můžeme popsat množinou funkcí tvořenou příkazy $\{KROK VPRED, OTOC VLEVO, OTOC VPRAVO\}$ a množinou terminálů s jediným příkazem $\{ZASTAV\}$. I bez dokázaní si můžeme jasně říci, že jsme schopní díky těmto příkazům dostat mravence do jakéhokoliv místa a zastavit.

\paragraph*{}
U jednoduchých příkladů, kde je množina terminálů a neterminálů tvořena pouze Booleovskými funkcemi můžeme i bez důkazů předpokládat, že takové množiny jsou uzavřené a splňují také podmínku postačitelnosti. Ovšem v reálných příkladech budeme často používat programy složené číselných proměnných a funkcích, podmínkách, rekurzích, ruzných typů v argumentech funkcí. Nebo budeme při práci s číselnými funkcemi muset ošetřit některé zakázané stavy (dělení nulou, logaritmus záporného čísla, atd.). V takových případech už podmínka uzavřenosti nemusí platit.

\paragraph*{}
I v těchto případech se však můžeme odkázat na Kozu, který tvrdí, že lze jednoduchým postupem zajistit, aby byly množiny terminálů a funkcí uzavřené pro obecně jakýkoliv problém. Vezměme si případ programu pracujícího s číselnými funkcemi a terminály, kde může nastat situace, že se bude muset provést dělení nulou. Proto je třeba upravit funkce z těchto množin tak, aby umožňovaly zpracovat také nedefinovatelnou hodnotu ("undefined") v podobě nějakého zástupného symbolu a ošetřit stavy funkcí tak, aby funkce mohla vrátit kromě čísla také tuto hodnotu v případech, kdy je operae zakákána nebo v případě, že alespoň jeden z argumentů vrací tuto hodnotu. Takto upravené funkce Koza nazývá chráněné funkce (protected functions).

\paragraph*{}
Vlastnost uzavřenosti množin je vhodná, ale není absolutně nutná. Jako alternativa k chráněným funkcím může sloužit jiný přístup. Pokud striktně nevyžadujeme, aby byl program syntaktického stromu validní, můžeme nesprávně generované stromy v populaci zakázat nebo je jinak penalizovat, aby nepřecházely do nových generací. V této práci se však takovým způsobům nebudeme zabývat a budeme pracovat pouze se splněnou podmínkou uzavřenosti.

\paragraph*{}
Protože výsledná funkce je tvořena nejen proměnnými, ale také konstantami, je třeba si říci, jak je při tvorbě jedince reprezentovat. Protože můžeme chtít použít GP pro ekonomické modelování, měl by mít algoritmus možnost generovat vhodné konstanty v daném rozsahu a daného typu podle řešené úlohy. Koza navrhuje množinu terminálů o náhodnou konstantu C tak, že se během běhu programu při ohodnocení individuí doplní o náhodnou hodnotu z příslučné množiny. Toto číslo se potom využije jako kterýkoliv jiný terminál.

\subsection{Množina funkcí a terminálů}
\paragraph*{}
Množina funkcí může obsahovat:
\begin{enumerate}
\item aritmetické operace (+, -, *, /, atd.)
\item matematické funkce (AND, OR, NOT, NAND, atd.)
\item podmínkové operátory (IF-THEN-ELSE)
\item iterační konstrukce (DO, FOREACH, WHILE)
\item rekurzivní funkce
\end{enumerate}

\paragraph*{}
Aby byl algoritmus GP skutečně úspěšný a efektivní při hledání vhodného řešení, musíme velmi pečlivě definovat množinu použitých funkcí a také terminálních symbolů. Chybí-li v množině funkcí nějaký klíčový krok, můžeme se nám tvorba správného programu zesložitit či v extrémním případě nemusíme dojít k řešení vůbec. Naproti tomu, pokud budeme mít množinu funkcí příliš bohatou, rozšíří se prostor možných řešení a tedy i časová složitost pro prohledání celého prostoru. Může se stát, že i přesto, že je výsledná funkce jednoduchá, bude přesto časově zdlouhavé, abychom toto řešení nalezli. Je to jako hledat jehlu v kupce sena. Vhodné je omezit funkce na co nejmenší počet.

\subsection{Reprezentace stromové struktury}
\paragraph*{}
Implementací syntaktického stromu je několik. Jednou z možností jak strom v počítačích reprezentovat je s použitím uzlů obsahující sezname potomků. Jde o přirozené vnímání stromové struktury, která je však při samotné implementaci dosti obtížně manipulovatelná. 

\paragraph*{}
Druhou možností je seznam, který představuje strom v prefixovém tvaru zápisu. Pořadí prvků v seznamu odpovídá pořadí navštívení každého uzlu ve stromě, při procházení stromu do hloubky. Zajištění zpětné rekonstrukce stromu nám umožňuje informace o tom, zda prvek patří do množiny terminálních symbolů nebo naopak do množiny funkcí a arita každé funkce. Příkladem takovéto stromové reprezentace je na obrázku níže.

\InsertFigure{Figures/tree_structure.png}{0.4\textwidth}{Reprezentace stromu}{fig:TreeStructure}

\subsection{Generování počáteční populace}
\paragraph*{}
Při prvotním generování populace se budeme zabývat, jakým způsobem lze náhodně vygenerovat několik individuí. Existují dvě metody řídící růst stromu. Úplná (full method), kdy všechny listové uzly stromu mají stejnou hloubku, která je rovna maximální velikosti stromu. Metoda růstová (grow method) naproti tomu dovoluje tvorbu rozmanitějších stromových struktůr. Pro generování následného potomka se náhodně rozhoduje, zda je použitý termínál nebo uzel. I zde je limitní maximální hloubka stromu.

\paragraph*{}
Koza ve své knize \cite{kozagp} doporučuje kombinaci obou metod, což v praxi znamená, že pro polovinu populace se použije růstová metoda a pro druhou polovinu úplná. Zároveň rovnoměrným rozložením hloubky stromů mezi všechny jedince, snížíme pravděpodobnost výskytu stejnývh řešení, která jsou v populaci nevyhovující. 

\paragraph*{}
Vše si můžeme ukázat na příkladě populace s $N=500$ jedinců, kde je stanovena maximální hloubka $h_max=6$. Při generování základní populace budeme postupovat tak, že 100 jedinců bude generováno s $h_max=2$ (50 s růstovou metodou a 50 s úplnou metodou),následně pro dalších 100 řešení generujeme obdobné stromy hloubký o 1 vyšší $h_max=3$ a tak dále, až do hloubky $h_max=6$.

\subsection{Operátory}

\subsubsection{Křížení}
\paragraph*{}
V GP budeme používat stejné operace jako u GA. Operátor křížení pracuje s dvojícemi stromů. U každého stromu z dvojíce zvolí náhodně uzel pro křížení a v dalším kroku zamění podstromy pod zvolenými uzly mezi sebou. Více osvětlíme příkladem na obrázku. Oproti GA se zde potkáváme s problémem postupného růstu hloubky reprezentujících stromů. V první generaci si obstaráme stromy, který mají definouvanou maximální hloubku. Při aplikaci křížení však snad nastává případ, kdy je například listový uzel jednoho stromu nahrazen téměř celým podstromem druhého jedince. V podstatě jen v případech, kdy se budou zaměňovat podstromy z uzlů, které jsou ve stejné hloubce se žádný z obou stromů nerozšiřuje. Ve všech ostatních případech bude jeden nebo druhý strom rozšířený.

\paragraph*{}
Koza doporučuje, abychom definovali i maximální hloubku stromů vzniklých křížením. Doporučuje se trojnásobek hloubky počáteční populace. Pokud bychom při křížení překročili tuto maximální povolenou hranici, takto vzniklí potomci budou odmítnuti a nahrazeni jedním z rodičovských jedinců.

\InsertFigure{Figures/cross.png}{0.7\textwidth}{Příklad operátoru křížení}{fig:CrossSample}
\paragraph*{}
Speciálním případem při křížení je tzv. "incestní křížení", které nastane tehdy, pokud do křížení vstoupí dva identiční jedinci. V případě GA je takový případ nežádoucí, protože vznikají identiční potomci. V případe GP k tomu nastává pouze tehdy, když by byl v obou stromech vybrán tentýž uzel pro křížení.

\subsubsection{Mutace}
\paragraph*{}
Operátor mutace také náhodně vybere uzel stromu a celý jeho podstrom odstraní. Na tomto místě se poté náhodně vygeneruje chybějící část stromu do maximální hloubky předepsané parametrem tak, aby vyýsledný strom nebyl příliš velký. 

\InsertFigure{Figures/mutate.png}{0.4\textwidth}{Příklad operátoru mutace}{fig:MutateSample}

\paragraph*{}
Variant operace mutace je několik. Mezi základní patří tyto:
\begin{enumerate}
\item uzlová mutace (point mutation) - neterminální uzel nahradí neterminálem se stejnou aritou a terminální uzel jiným terminálem
\item vyzvedávající mutace (boist mutation) nahrazuje celý syntaktický strom některým z jeho podstromů
\item smršťující mutace (shrink mutation) nahrazuje náhodně zvolený podstrom jediným terminálem
\end{enumerate}

\subsubsection{Další operátory}
\paragraph*{}
To však není celý výčet možných operátorů. Existují i operátor, které se v GP nevyužívají zcela běžně, ale stojí za to se o nich zmínit. Mezi méně časté operátory řadíme například operátor permutace, zapouzdření, editace či decimace.

\paragraph*{}
Operátor permutace je příkladem asexuálního operátora, který využívá jen jednoho rodiče a náhodně zvolí neterminál s n operátory, jejichž pořadí náhodně prohodí. Jde tedy o náhodné prohození pořadí větví takovéhoto podstromu.

\paragraph*{}
Operátor editace se snaží poskytnou nedestruktivní redukci hloubky stromu tak, aby výsledný strom představoval tentýž program, ale bez přebytečných uzlů. Nejlépe, když si takový případ ukážeme na obrázku.

\InsertFigure{Figures/editace.png}{0.7\textwidth}{Příklad operátoru editace. Levý strom zjednodušíme a výsledkem je strom pravý}{fig:EditSample}

\subsection{Popis algoritmu}
\paragraph*{}
Před tím, než se pustíme do popisu toho, co jsou to evoluční algoritmy a na jakých principech fungují, se seznámíme s tím, co jsou to „evoluční výpočetní techniky“.

\begin{example}
\label{priklad}
Postup evolučního algoritmu
\begin{enumerate}
\item Vymezení parametrů evoluce – jako je stanovení kritéria ukončení (počet cyklu, vhodnost řešení,…), stanovení účelové funkce, případně tzv. vhodnosti. Účelovou funkcí se rozumí obvykle matematický model, jehož minimalizace/maximalizace vede k řešení
\item Generování prvopočáteční populace (obecně matice M x N, kde M je počet parametrů jedince a M je počet jedinců v populaci). Jedincem se rozumí vektor čísel s takovým počtem složek, kolik je optimalizovaných parametrů. Složky jsou nastaveny nahodile a každý jedinec představuje jedno možné řešení
\item Všichni jedinci se ohodnotí přes definovanou účelovou funkci a každému z nich se přiřadí: a) buď přímá hodnota vrácená účelovou funkcí, nebo b) vhodnost, což je upravená hodnota účelové funkce
\item Nastává výběr rodičů podle jejich kvality
\item Křížením rodičů se tvoří potomci. Proces křížení je u každého algoritmu odlišný.
\item Každý potomek je zmutován
\item Každý jedinec se ohodnotí stejně jako v kroku 3.
\item Vyberou se nejlepší jedinci
\item Vybraní jedinci zaplní novou populaci
\item Stará populace je zapomenuta a na její místo nastupuje populace nová. Dále se pokračuje krokem 4.
\end{enumerate}

\paragraph*{}
Evoluční algoritmy nejsou populární jen proto, že jsou moderní a odlišné od klasických, ale hlavně pro fakt, že v případě vhodného aplikování jsou schopny nahradit člověka
\end{example}

\section{Implementace GP}
\paragraph*{}
Před tím, než se pustíme do popisu toho, co jsou to evoluční algoritmy a na jakých principech fungují, se seznámíme s tím, co jsou to „evoluční výpočetní techniky“.

\subsection{Evoluční procesy}
\paragraph*{}
Evoluční procesy, do kterých řadíme "přirozený výběr", "mutaci", "křížení" a další techniky, které jsou inspirované zákonitostmi v přírodě jsou základním kamenem pro jakýkoliv program napodobující evoluční chování za pomocí počítačů. Proto je teřba dbát o co nejvhodnější a nejpreciznější implementaci tak, aby byl výsledný algoritmus dobře použitelný i pro nejrůznější problémy. Představme si nyní některá úskalí, která je třeba dobře postihnout a zefektivnít výsledný kód.

\subsubsection{Výběrová funkce}
\paragraph*{}
V evolučních technikách se využívá vždy a ovlivňuje populační vývoj, protože předchází evoluční operátory (křížení, mutaci). Tato funkce se má stát přirozeným výběrem, který v přírodě funguje již od pradána. Tedy právo silnějšího (odolnějšího, přizpůsobivějšího) jedince na tvorbu nové generace.

\paragraph*{}
Několik pravidel pro efektivnější výběrovou funkci:
\begin{enumerate}
\item Zamezení výběru dvou totožných jedinců pro křížení
\item Možnost vícenásobného výběru stejného jedince (posílení vlivu lepších řešení do dalších populací)
\end{enumerate}

\subsection{UML model}
\paragraph*{}
Před tím, než se pustíme do popisu toho, co jsou to evoluční algoritmy a na jakých principech fungují, se seznámíme s tím, co jsou to „evoluční výpočetní techniky“.

\subsection{Aplikace EvolTools}
\paragraph*{}
Před tím, než se pustíme do popisu toho, co jsou to evoluční algoritmy a na jakých principech fungují, se seznámíme s tím, co jsou to „evoluční výpočetní techniky“.

\section{Testování na vybraných problémech}
\paragraph*{}
Po představení pestré, ale zdaleka né kompletní, škály algoritmů je třeba si představit a vyhodnotit jejich sílu na problémech, které se objevují v mnoha publikacích jako vhodní adepti. V následujících pasážích si představíme ty nejběžnější avšak netriviální problémy. U každé definice problému je popsáno, jakými evolučními algoritmy je vhodné tyto problémy řešit. Spolu s definicí problému si popíšeme i výsledky, které byly během testování zaznamenány a konfigurace s jakými byly algoritmy spouštěny. Podtržením toho všeho bude srovnání s výsledky, které byly zveřejněny v publikacích jako optimální, přičemž nemáme za cíl dosáhnout co nejlepšího řešení, ale orientačně vyhodnotit použitelnost na problémech s přihlédnutím k tomu, že výsledným produktem této práce bude aplikace sloužící jako opora při úvodu do problematiky a výuky evolučních algoritmů a hlavně genetického programování.

\subsection{Umělý mravenec}
\paragraph*{}
Běžně úváděným problémem pro genetické algoritmy je úkol navést umělého mravence tak, aby se pokusil nalézt všechnu potravu ležící podél nepravidelné stezky. Cílem problému je nalezení konečného automatu, který by v konečném čase dosáhl daného problému. \cite{gpcm}

\paragraph*{}
Umělý mravence se pohybuje po dvourozměrné toroidní mřížce 32x32 polí tak, že začíná v levém horním rohu na souřadnicích (0,0) a směřuje po "Santa Fe" stezce až na konec. Na této stezce se přitom vyskytuje 89 nepravidelně rozložených polí s potravou. Mimo polí s potravou se na této stezce vyskytuje množství mezer délky až 3 buňky, kde potrava není, a to nejen na rovných úsecích, ale také v rozích.

\paragraph*{}
Celá stezka je zobrazena na obrázku. Jídlo reprezentují tmavá pole. Spolu s jídlem jsou na stezce mezery, které jsou na obrázku v šedé barvě.

\InsertFigure{Figures/santa-fe.png}{0.7\textwidth}{Stezka Santa Fe}{fig:santafe}

\paragraph*{}
Umělý mravenec má velmi omezený pohled na svět kolem. Má senzor, kterým může vidět pouze na sousední buňku bezprostředně následují před mravencem a může provádět pouze některé z následujících primitivních akcí:

\begin{itemize}
\item RIGHT otočení mravence o 90 doprava
\item LEFT otočení mravence o 90 doleva
\item MOVE pohyb mravence o jedno políčko vpřed, ve směru natočení
\end{itemize}

Pro problém budeme také potřebovat zpracovávat informace z vnějšího světa pomocí malého senzoru mravence. Rozumným přístupem jak toho dosáhnout je použití podmíněného operátoru pro rozvětvení programu instrukcí a také operátoru pro sekvenční provádění instrukcí.

\begin{itemize}
\item IF-FOOD-AHEAD přijímá dva argumenty a spustí první v případě, že se bezprostředně před mravencem nachází potrava, jinak se vykoná instrukce z druhého argumentu
\item PRG2 přijímá dva argumenty, které se sekvenčně po sobě vykonají
\item PRG2 přijímá tři argumenty, které se sekvenčně po sobě vykonají
\end{itemize}

\subsection{Symbolická regrese}
\paragraph*{}
Symbolická regrese (dále jako SR) se v publikacích popisována jako statická metoda používaná k předpovídání hodnot nějaké proměnné, závislé a jedné nebo více nezávislých proměnných. Snaží se odhalit vnitřní vztahy v datovém souboru. Jde tedy o inverzní postup pro získání symbolického tvaru (původního předpisu funkce) na základě tohoto souboru dat - množina hodnot z definičního oboru funkce. 

\paragraph*{}
Obecně může jít o jakoukoliv funkci např. $y=sin(x)+1/e^x$. Symbolická regrese je jeden z možných způsobů, jak najít vhodnou regresní funkci pro zadaná data.

\paragraph*{}
Regresní funkce může být zkonstruována kombinací elementárních funkcí, jako jsou matematické operátory: sčítání ($+$), odčítání ($-$), násobení ($*$), dělení ($/$), goniometrické funkce: sinus ($\sin(x)$), cosinus ($\cos(x)$), proměnné:  $x, y, z, ...$, a konstant: $a, b, c, ...$. 

\paragraph*{}
V GP je cílová regresní funkce konstruována a upřesňována během evolučního procesu. Na začátku se v závislosti na velikosti populace a matematických výrazech, proměnných, respektive konstantách vytvoří počáteční populace, kde každý jedinec představuje jednu z možných regresních funkcí.

\paragraph*{}
Fitness funkce, která řídí vývoj modelů bere v úvahu nejen chybové metriky (s cílem zajistit modely přesně předpovědět data), ale také ...

\paragraph*{}
Zatímco běžné regresní techniky se snaží optimalizovat parametry pro předem specifikované modelové struktury, symbolická regrese žádné modelové struktury nepředpokladá, a místo toho vyvozuje tento model ze samotných dat. Jinými slovy, se pokouší zjistit, jak modelové struktury, tak parametry. Tento přístup má samozřejmě nevýhodu v mnohem větším prostoru k prohledání - ve skutečnosti, je nekonečný ne jen prostor pro modely symbolické regrese, ale existuje nekonečné množství modelů, které se perfektně hodí na konečná množina dat (za předpokladu, že složitost modelu není uměle omezena). 

\InsertFigure{Figures/regression_example.png}{0.7\textwidth}{Regresní funkce (modrá) s nalezenou aproximaxí (červeně)}{fig:reg_sample}

\paragraph*{}
Velikost prohledávaného prostoru, a tak i časovou náročnost pro nalezení modelu lze omezit tím, že omezíme sadu stavebních bloků poskytnutých algoritmu na základě stávajících znalostí systému, který produkoval data. Nicméně, tento rys symbolické regrese má také výhodu - evoluční algoritmus využívá rozmanitosti generování modelu, a tak účinně prozkoumává prostor možných řešení. V konečném výsledku je proto pravděpodobné, že z výběru navržených modelů, které celkem optimálně aproximují datový soubor, můžeme poskytnout lepší vhled do systému, a umožňuje uživateli identifikovat aproximaci, která lépe vyhovuje potřebám (co do přesnosti a jednoduchosti).

\paragraph*{}
Symbolická regrese má široké využití. Mezi nejčastější možnosti aplikace bychom mohli zařadit:
\begin{enumerate}
\item Syntéza logických obvodů
\item Syntéza neuroových sítí
\item Syntéza trajektorií robotů
\item Aproximace funkcí
\end{enumerate}

\subsubsection{Aproximace funkcí}
\paragraph*{}
Pro otestování životaschopnosti a správnosti implementovaného algoritmu GP bylo vytvořeno rozhraní také pro aproximaci neznáméh modelu funkce za pomocí předložených dat. Cílem bylo nalezení modelu funkce k dosažení co možná nejoptimálnějšího proložení dat.

\paragraph*{}
K testvání byly použity polynomy pátého a šestého řádu, tzv. Sextic a Quintic problémy a dvojice trignometrických funkcí s značením 3Sine a 4Sine problémy \cite{evolvyptech}.

\subsubsection{Quintic a Sextic problem}
\paragraph*{}
Problém označovaný jako Quintic a Sextic problem jsou označením pro všechny polynomiální funkce pátého a šestého řádu. V této práci se jednalo o funkce definované vztahy \ref{eq:quitic} a \ref{eq:sextic}.

\begin{equation} \label{eq:quitic}
x^5-2x^3+x
\end{equation}

\begin{equation} \label{eq:sextic}
x^6-2x^4+x^2
\end{equation}

\paragraph*{}
Pro účely testování navržené aplikace bylo použito následujících nastavení evolučního běhu. Aby nebyly výsledky testování zkreslené, byla jednotlivá syntéza funkcí opakována 20 krát. Konfigurace k aproximaci Quintic a Sextic funkce je uvedená v tabulce \ref{tab:QuinticSexticConf} 

\begin{table}
  \centering
  \begin{tabular}{| r | p{9cm} |} \hline
    Datový soubor & tvoře 50 vzorky s krokem 0,4 a rozmezí [-1;1] \\ \hline
    Velikost chyby & Suma absolutních hodnot rozdílů mezi původí hodnotou a hodnotou syntetizované funkce \\ \hline
    Množina funkcí & $+, -, *, pow(a,b)$ \\ \hline
    Množina terminálů & konstanty s nastavenou mezí [-10;10] a nezávislá proměnná $x$ \\ \hline
    Počet generací & 500 evolučních cyklů \\ \hline
    Velikost populace & 200 jedinců \\ \hline
    Výška stromu & 6 \\ \hline
    Pravděpodobnost křížení & 0.7 \\ \hline
    Pravděpodobnost mutace & 0.28 \\ \hline
    Pravděpodobnost reprodukce & 0.02 \\ \hline
    Metoda křížení & Tournament (velikost 10) \\ \hline
  \end{tabular}
  \label{tab:QuinticSexticConf}
  \caption{Konfigurace GP pro Sextic problém}
\end{table}

\InsertFigure{Figures/quintic-problem-origin.png}{1.0\textwidth}{Průběh funkce $x^5-2x^3+x$}{fig:quintic_fce}

\InsertFigure{Figures/quintic-problem-result.png}{1.0\textwidth}{Výsledná aproximace funkce $x^5-2x^3+x$}{fig:quintic_aprox}

\InsertFigure{Figures/sextic-problem-origin.png}{1.0\textwidth}{Průběh funkce $x^6-2x^4+x^2$}{fig:sextic_fce}

\InsertFigure{Figures/sextic-problem-result.png}{1.0\textwidth}{Výsledná aproximace funkce $x^6-2x^4+x^2$}{fig:sextic_aprox}

\paragraph*{}
Simulace aproximace pro oba problémy byla opakována 20-krát. Na obrázku jsou zobrazena data a jejich proložení všemi syntetizovanými funkcemi. Lze si všimnout, že všechny nalezené syntetizované funkce celkem věrohodně aproximují původní funkce.

\paragraph*{}
Mezi nejlepší aproximaci funkce Sextic patřily výsledné funkce $(x^3-x)*(x^3-x)$ a $(x^3-x)*(x^3-x)$, které po úpravě (roznásobení) skutečně dávají původní funkci \ref{eq:sextic}.
Stejně tak při hledání optimální funkce Quintic \ref{eq:quitic} problemu bylo během opakovaného běhu programu dosaženo optimálních řešení v podobě funkce $x-(((x+x)*(x*x))-(x^5))$


\InsertFigure{Figures/fitness-quintic.png}{1.0\textwidth}{Vývoj fitness nejlepšich nalezených řešení Quintic funkce}{fig:fitnessQuintic}

\InsertFigure{Figures/fitness-sextic.png}{1.0\textwidth}{Vývoj fitness nejlepšich nalezených řešení Sextic funkce}{fig:fitnessSextic}

\subsection{Vyhodnocení}
\paragraph*{}
Nějaké zhodnocení

\section{Závěr}
\label{sec:Conclusion}
Tak doufám, že Vám tato ukázka k něčemu byla. Další informace najdete v publikacích
\cite{goossens94,lamport94}.

\bigskip
\begin{flushright}
Zdeněk Gold
\end{flushright}

\begin{thebibliography}{99}

\bibitem{kozagp} Koza, J. R.,
\textit{Genetic programming. On the Programming of Computers by Means of Natural Selection},
Cambridge, MA: MIT Press, 1992.

\bibitem{evoltech} Dostál, M.,
\textit{Evluční výpočetní techniky},
Olomouc, Přírodovědecká fakulta: 2007.

\bibitem{evolvyptech} Zelinka, I., Oplatkova, Z., Šeda, M., Ošmera, P., Včelař, F.,
\textit{Evluční výpočetní techniky, principy a aplikace},
Praha, BEN - technická literatura: 2009.

\bibitem{kozagp2} Koza, J. R.,
\textit{Genetic programming II. Automatic Discovery of Reusable Programs},
Cambridge, MA: MIT Press, 1994.

\bibitem{goossens94} Goossens, Michel,
\textit{The \LaTeX\ companion,} New York: Addison, 1994.

\bibitem{lamport94} Lamport, Leslie,
\textit{A document preparation system: user's guide and reference manual},
New York: Addison-Wesley Pub. Co., 2015.

\bibitem{geneticprog98} Koza J.R, 
\textit{Genetic Programming},
MIT Press, ISBN 0-262-11189-6, 1998

\bibitem{geneticprogIII} Koza J.R, Bennet F.H., Andre D., Keane M.,
\textit{Genetic Programming III},
Morgan Kaufnamm pub., ISBN 1-55860-543-6, 1999

\bibitem{optimization} Lampinen Jouni, Zelinka, Ivan,
\textit{New Ideas in Optimization and Mechanical Engineering Design Optimization by Differential Evolution. Volume 1},
London: McGraw-Hill, 1999. 20 p. ISBN 007-709506-5

\bibitem{gpcm} Koza, John R.,
\textit{Genetic Programming On the Programming of Computers by Means of Natural Selection, Volume 6},
London, England: The MIT Press, 1998. 819 p. ISBN 0262111705, 9780262111706

 

\end{thebibliography}

\end{document}
